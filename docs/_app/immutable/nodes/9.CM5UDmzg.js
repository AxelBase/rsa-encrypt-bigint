import{a as i,f as c}from"../chunks/D0kFrxlX.js";import"../chunks/FUx1wh6e.js";import{w as r,x as u,y as x,A as v,$ as y,z as t,B as n,D as o}from"../chunks/CZGqv6FW.js";import{h as f}from"../chunks/ByTrk-YZ.js";import{s as l}from"../chunks/l1hb7SSs.js";import{b as p}from"../chunks/d-LnGFPL.js";const b=!0,F=Object.freeze(Object.defineProperty({__proto__:null,prerender:b},Symbol.toStringTag,{value:"Module"}));var k=c('<meta name="description" content="See the complete process of converting plaintext to ciphertext using RSA in a browser environment, step by step."/> <meta property="og:title" content="RSA Encryption in Practice: From Text to Ciphertext | RSA BigInt Demo Blog"/> <meta property="og:description" content="See the complete process of converting plaintext to ciphertext using RSA in a browser environment, step by step."/> <meta property="og:url"/> <meta property="og:type" content="article"/> <meta name="twitter:card" content="summary_large_image"/>',1),q=c('<div class="container fade-in post-layout svelte-q8x3kg"><div class="breadcrumbs svelte-q8x3kg"><a class="svelte-q8x3kg">Blog</a> <span class="svelte-q8x3kg">/</span> <p class="svelte-q8x3kg">RSA Encryption in Practice: From Text to Ciphertext</p></div> <article class="prose svelte-q8x3kg"><h1 class="svelte-q8x3kg">RSA Encryption in Practice: From Text to Ciphertext</h1> <p class="post-meta svelte-q8x3kg">Published: February 20, 2026</p> <p class="svelte-q8x3kg">Encrypting a message with RSA involves several straightforward but powerful steps. First, the plaintext string is transformed into a single large integer. This is typically done by encoding the text as bytes using a standard like UTF-eight, then interpreting those bytes as a base-two hundred fifty-six number. The resulting integer must be smaller than the modulus n to ensure correct recovery.</p> <p class="svelte-q8x3kg">Once converted, the message integer is raised to the power of the public exponent e, and the result is taken modulo n. This produces the ciphertext, another large integer usually displayed in hexadecimal for readability. Because modular exponentiation is used, the operation remains efficient despite the enormous sizes involved.</p> <p class="svelte-q8x3kg">The ciphertext appears completely random and unrelated to the original message. Only the holder of the matching private exponent d can reverse the process by raising the ciphertext to the power d modulo n, recovering the exact original integer, which is then decoded back to text.</p> <h2 class="svelte-q8x3kg">Textbook vs Real-World RSA</h2> <p class="svelte-q8x3kg">This demo uses textbook RSA, meaning raw modular exponentiation without additional padding or randomization. While educational and perfect for understanding the math, real systems add padding to prevent attacks that exploit patterns in short or predictable messages.</p> <h3>Key Observations in Use</h3> <ul class="svelte-q8x3kg"><li class="svelte-q8x3kg">Message length is limited by the key size</li> <li class="svelte-q8x3kg">Encryption is fast due to small public exponent</li> <li class="svelte-q8x3kg">Output is always roughly the same length as the modulus</li></ul> <p class="svelte-q8x3kg">In the utility, you provide n and e from generated keys, type a message, and instantly see the hexadecimal ciphertext. This hands-on approach helps build intuition about how asymmetric encryption protects data in transit.</p> <h2 class="svelte-q8x3kg">FAQ</h2> <details class="svelte-q8x3kg"><summary class="svelte-q8x3kg">What happens if the message is too large?</summary> <p class="svelte-q8x3kg">The encryption fails or produces incorrect results; the message must always be numerically smaller than n.</p></details> <details class="svelte-q8x3kg"><summary class="svelte-q8x3kg">Why show ciphertext in hex?</summary> <p class="svelte-q8x3kg">Hexadecimal is compact and human-readable for large integers, making it easy to copy and verify.</p></details> <details class="svelte-q8x3kg"><summary class="svelte-q8x3kg">Is the process reversible?</summary> <p class="svelte-q8x3kg">Yes, applying the private key reverses encryption exactly, proving the mathematical correctness.</p></details> <p class="italic-note svelte-q8x3kg">The final article discusses why this raw form of RSA is ideal for learning despite not being production-ready.</p></article></div>');function B(h){var e=q();f("q8x3kg",g=>{var a=k(),d=u(x(a),6);t(4),r(()=>l(d,"content",`${p??""}/blog/posts/post6`)),v(()=>{y.title="RSA Encryption in Practice: From Text to Ciphertext | RSA BigInt Demo Blog"}),i(g,a)});var s=n(e),m=n(s);t(4),o(s),t(2),o(e),r(()=>l(m,"href",`${p??""}/blog`)),i(h,e)}export{B as component,F as universal};
